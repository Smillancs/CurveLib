#version 420

layout (isolines,equal_spacing) in;

in block
{
	vec3	pos;
} In[];

out block
{
	vec3	pos;
	vec3	col;
	vec3	patch_coords;
	float	k;
	float	t;
} Out;

uniform mat4 VP;
uniform mat4 world;
uniform mat4 worldIT;
uniform int pointNum = 1;

int factorial(int n)
{
	int temp = 1;
	for (int i = 1; i <= n; ++i)
	{
		temp*=i;
	}
	return temp;
}

float binomial(int n, int k)
{
	return factorial(n)/(factorial(k)*factorial(n-k));
}

float Bernstein(int n, int i, float t)
{
	return binomial(n,i)*pow(t,i)*pow(1.0-t,n-i);
}

vec3 BernsteinEval(float t)
{
	vec3 temp = vec3(0,0,0);
	for(int i = 0; i < pointNum; ++i)
	{
		temp += Bernstein(pointNum-1,i,t)*In[i].pos;
	}
	return temp;
}

vec3 ForwardDiff(int order, int idx)
{
	vec3 delta = vec3(0,0,0);
	int alternate = bool(order%2)?-1:1;
	for (int j = 0; j <= order; ++j)
	{
		delta += binomial(order, j) * float(alternate) * In[idx+j].pos;
		alternate *= -1;
	}
	return delta;
}

vec3 Diff(int order, float t)
{
	vec3 eval = vec3(0,0,0);
	int n = pointNum - order - 1;

	for (int j = 0; j <= n; ++j)
	{
		eval += ForwardDiff(order,j) * Bernstein(n,j,t);
	}
	eval *= factorial(pointNum-1)/float(factorial(n));
	return eval;
}

vec3 e(float t)
{
	vec3 normed = (Diff(1,t)!=vec3(0,0,0))?
		normalize(Diff(1,t)):
		vec3(0,0,0);
	return normed;
}

vec3 b(float t, int limit = 5)
{
	int i = 2;
	while( cross( Diff(1,t), Diff(i,t) ) == vec3(0,0,0) && i < limit ) ++i;
	vec3 crossed = cross(Diff(1,t), Diff(i,t));
	vec3 normed = (crossed != vec3(0,0,0))?
		normalize(crossed):
		vec3(0,0,0);
	return normed;
}

vec3 n(float t)
{
	return cross(b(t), e(t));
}

float frenet_coordinate_e(float t, int order)
{
	return dot(Diff(order,t), e(t));
}

float frenet_coordinate_n(float t, int order)
{
	return dot(Diff(order,t), n(t));
}

float frenet_coordinate_b(float t, int order)
{
	return dot(Diff(order,t), b(t));
}

float K(float t)
{
	float x1 = frenet_coordinate_e(t,1);
	float y2 = frenet_coordinate_n(t,2);
	return y2 / (x1 * x1);
}

float dK(float t)
{
	float x1 = frenet_coordinate_e(t,1);
	float x2 = frenet_coordinate_e(t,2);
	float y2 = frenet_coordinate_n(t,2);
	float y3 = frenet_coordinate_n(t,3);
	return (y3 * x1 - 3 * x2 * y2) / (x1 * x1 * x1 * x1);
}

float ddK(float t)
{
	float x1 = frenet_coordinate_e(t,1);
	float x2 = frenet_coordinate_e(t,2);
	float x3 = frenet_coordinate_e(t,3);
	float y2 = frenet_coordinate_n(t,2);
	float y3 = frenet_coordinate_n(t,3);
	float y4 = frenet_coordinate_n(t,4);
	return (y4 * x1 * x1 - 5 * x2 * y3 * x1 + 12 * x2 * x2 * y2 - 4 * y2 * x3 * x1 - 3 * y2 * y2 * y2) / (x1 * x1 * x1 * x1 * x1 * x1);
}

float T(float t)
{
	float x1 = frenet_coordinate_e(t,1);
	float y2 = frenet_coordinate_n(t,2);
	float z3 = frenet_coordinate_b(t,3);
	return (y2 == 0) ? 0.0 : z3 / (x1 * y2);
}

float dT(float t)
{
	float x1 = frenet_coordinate_e(t,1);
	float y2 = frenet_coordinate_n(t,2);
	float y3 = frenet_coordinate_n(t,3);
	float z3 = frenet_coordinate_b(t,3);
	float z4 = frenet_coordinate_b(t,4);
	return (y2 == 0) ? 0.0 : (z4 * y2 - 2 * z3 * y3) / (x1 * x1 * y2 * y2);
}

void main()
{
	float u = gl_TessCoord.x;
	vec3 bpos = BernsteinEval(u);
	gl_Position = VP*vec4(bpos,1);
	Out.pos = (world*vec4(bpos,1)).xyz;
	Out.patch_coords = gl_TessCoord.xyz;
	Out.k = K(u);
	Out.t = T(u);
	Out.col = vec3(0);
}
